#!/bin/bash
# =============================================================================
# PLATFORM SETUP SCRIPT
# =============================================================================
# This script sets up the PLATFORM LAYER on an EKS cluster.
# Run this ONCE per cluster after Terraform creates the infrastructure.
#
# What it does:
#   1. Installs ArgoCD
#   2. Installs ExternalDNS with IRSA
#   3. Sets up initial ArgoCD configuration
#
# Prerequisites:
#   - kubectl configured for EKS cluster
#   - aws CLI authenticated
#   - IRSA roles created via Terraform
#
# Usage: ./platform-setup.sh
#
# =============================================================================

set -e

# =============================================================================
# CONFIGURATION (FROM TERRAFORM)
# =============================================================================
CLUSTER_NAME="${CLUSTER_NAME:-argocd-nonprod-eks}"
AWS_REGION="${AWS_REGION:-us-west-1}"
HOSTED_ZONE_ID="${HOSTED_ZONE_ID:-Z00814191D1XSXELJVTKT}"
DOMAIN="${DOMAIN:-opsera-labs.com}"

# Derived from Terraform outputs (or set manually)
EXTERNAL_DNS_ROLE_ARN="${EXTERNAL_DNS_ROLE_ARN:-}"

echo ""
echo "========================================"
echo "  PLATFORM SETUP: ${CLUSTER_NAME}"
echo "========================================"
echo ""

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================
log_step() {
    echo ""
    echo ">>> $1"
    echo ""
}

log_skip() {
    echo "    [SKIP] $1"
}

log_done() {
    echo "    [DONE] $1"
}

# =============================================================================
# STEP 0: VERIFY PREREQUISITES
# =============================================================================
log_step "Step 0: Verifying prerequisites"

if ! command -v kubectl &>/dev/null; then
    echo "ERROR: kubectl not found. Please install kubectl."
    exit 1
fi

if ! command -v aws &>/dev/null; then
    echo "ERROR: aws CLI not found. Please install AWS CLI."
    exit 1
fi

# Connect to cluster
aws eks update-kubeconfig --name "$CLUSTER_NAME" --region "$AWS_REGION" >/dev/null 2>&1
log_done "Connected to cluster: $CLUSTER_NAME"

# Get IRSA role ARN from Terraform if not set
if [ -z "$EXTERNAL_DNS_ROLE_ARN" ]; then
    EXTERNAL_DNS_ROLE_ARN="arn:aws:iam::$(aws sts get-caller-identity --query 'Account' --output text):role/external-dns-${CLUSTER_NAME}"
    echo "    Using default IRSA role: $EXTERNAL_DNS_ROLE_ARN"
fi

# =============================================================================
# STEP 1: INSTALL ARGOCD (IDEMPOTENT)
# =============================================================================
log_step "Step 1: Installing ArgoCD"

if kubectl get namespace argocd 2>/dev/null; then
    if kubectl get deployment argocd-server -n argocd 2>/dev/null; then
        log_skip "ArgoCD already installed"
    else
        echo "    ArgoCD namespace exists but deployment missing, installing..."
        kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
        log_done "ArgoCD installed"
    fi
else
    kubectl create namespace argocd
    kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
    log_done "ArgoCD installed"
fi

# Wait for ArgoCD to be ready
echo "    Waiting for ArgoCD server to be ready..."
kubectl rollout status deployment/argocd-server -n argocd --timeout=300s

# =============================================================================
# STEP 2: INSTALL EXTERNAL DNS (IDEMPOTENT)
# =============================================================================
log_step "Step 2: Installing ExternalDNS"

if kubectl get deployment external-dns -n kube-system 2>/dev/null; then
    log_skip "ExternalDNS already installed"
else
    # Create ExternalDNS manifest with substituted values
    cat << EOF | kubectl apply -f -
apiVersion: v1
kind: ServiceAccount
metadata:
  name: external-dns
  namespace: kube-system
  annotations:
    eks.amazonaws.com/role-arn: ${EXTERNAL_DNS_ROLE_ARN}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: external-dns
rules:
  - apiGroups: [""]
    resources: ["services", "endpoints", "pods"]
    verbs: ["get", "watch", "list"]
  - apiGroups: ["extensions", "networking.k8s.io"]
    resources: ["ingresses"]
    verbs: ["get", "watch", "list"]
  - apiGroups: [""]
    resources: ["nodes"]
    verbs: ["list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: external-dns
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: external-dns
subjects:
  - kind: ServiceAccount
    name: external-dns
    namespace: kube-system
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: external-dns
  namespace: kube-system
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: external-dns
  template:
    metadata:
      labels:
        app: external-dns
    spec:
      serviceAccountName: external-dns
      securityContext:
        runAsNonRoot: true
        runAsUser: 65534
        fsGroup: 65534
      containers:
        - name: external-dns
          image: registry.k8s.io/external-dns/external-dns:v0.14.0
          args:
            - --source=service
            - --source=ingress
            - --provider=aws
            - --aws-zone-type=public
            - --registry=txt
            - --txt-owner-id=${HOSTED_ZONE_ID}
            - --domain-filter=${DOMAIN}
            - --policy=sync
            - --interval=1m
            - --log-level=info
          resources:
            requests:
              cpu: 25m
              memory: 64Mi
            limits:
              cpu: 100m
              memory: 128Mi
          securityContext:
            readOnlyRootFilesystem: true
            allowPrivilegeEscalation: false
EOF
    log_done "ExternalDNS installed"
fi

# Wait for ExternalDNS to be ready
kubectl rollout status deployment/external-dns -n kube-system --timeout=120s

# =============================================================================
# STEP 3: GET ARGOCD CREDENTIALS
# =============================================================================
log_step "Step 3: Getting ArgoCD credentials"

ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" 2>/dev/null | base64 -d)
if [ -n "$ARGOCD_PASSWORD" ]; then
    echo "    Admin password: $ARGOCD_PASSWORD"
else
    echo "    [WARN] Initial admin secret not found (may have been deleted)"
fi

# =============================================================================
# SUMMARY
# =============================================================================
echo ""
echo "========================================"
echo "  PLATFORM SETUP COMPLETE!"
echo "========================================"
echo ""
echo "  Installed Components:"
echo "    - ArgoCD (namespace: argocd)"
echo "    - ExternalDNS (namespace: kube-system)"
echo ""
echo "  Access ArgoCD UI:"
echo "    kubectl port-forward svc/argocd-server -n argocd 8080:443"
echo "    Open: https://localhost:8080"
echo "    Username: admin"
echo "    Password: ${ARGOCD_PASSWORD:-<check argocd-initial-admin-secret>}"
echo ""
echo "  Verify ExternalDNS:"
echo "    kubectl logs -l app=external-dns -n kube-system"
echo ""
echo "  Next Steps:"
echo "    1. Create ArgoCD repository secrets for your Git repos"
echo "    2. Deploy your first application with ArgoCD"
echo ""
echo "========================================"
